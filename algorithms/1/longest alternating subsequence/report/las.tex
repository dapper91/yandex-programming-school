\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{fullpage}


\title{\bf Домашнее задание №1}
\author{Д.А. Першин}
\date{\today}


\begin{document}
\maketitle


\section{Словесное описание алгоритма}
При решении данной задачи будем использовать метод динамического программирования. Будем обрабатывать входной массив в обратном порядке, чтобы найти наименьшую в лексикографическом порядке подпоследоветльность. Назовем его $\alpha$.
Создадим четыре массива: $L_<$, $L_>$, $P_<$, $P_>$. В этих массивах будем хранить элементы ${l_<}_i$, ${l_>}_i$, ${p_<}_i$, ${p_>}_i$ соответственно, где

\begin{description}

\item[${l_<}_i$] - длина наибольшей чередующейся подпоследовательности $\alpha_{x_0}\dots \alpha_{x_k}\alpha_i$
обратной входной последовательности $\alpha$, заканчивающийся в $\alpha_i$, такой, что $\alpha_{x_k}<\alpha_i$.

\item[${l_>}_i$] - длина наибольшей чередующейся подпоследовательности $\alpha_{x_0}\dots \alpha_{x_k}\alpha_i$
обратной входной последовательности $\alpha$, заканчивающийся в $\alpha_i$, такой, что $\alpha_{x_k}>\alpha_i$.

\item[${p_<}_i$] - индекс предыдущего элемента для $\alpha_i$ в наибольшей чередующейся подпоследовательности
$\alpha_{x_0}\dots\alpha_{x_k}\alpha_i$ обратной входной последовательности $\alpha$,
заканчивающийся в $\alpha_i$, такой, что $\alpha_{x_k}<\alpha_i$.
\item[${p_>}_i$] - индекс предыдущего элемента для $\alpha_i$ в наибольшей чередующейся подпоследовательности
$\alpha_{x_0}\dots\alpha_{x_k}\alpha_i$ обратной входной последовательности $\alpha$,
заканчивающийся в $\alpha_i$, такой, что $\alpha_{x_k}>\alpha_i$.
\end{description}

\paragraph{Алгоритм:}

\begin{enumerate}

\item Заполним массивы $L_<$ и $L_>$ значением $1$, а массивы $P_<$ и $P_>$ значением $-1$.

\item Для каждого элемента $\alpha_i$ из $\alpha$ найдем значения ${l_<}_i,{p_<}_i,{l_>}_i,{p_>}_i$, заполнив массивы $L_<$, $L_>$, $P_<$, $P_>$ следующим образом:

	\begin{itemize}
	
	\item если $ \alpha_j < \alpha_i $ и $ L_>[j] \ge L_<[i] $, то $ L_<[i] = L_>[j] + 1 $, а $ P_<[i] = j $.

	\item если $ \alpha_j > \alpha_i $ и $ L_<[j] \ge L_>[i] $, то $ L_>[i] = L_<[j] + 1 $, а $ P_>[i] = j $.
	\end{itemize}
	где $j \in [0, i-1]$	

\item В массивах $ L_< $ и $ L_> $ найдем максимум (при этом, если максимумов несколько, то выбираем максимум с наибольшим индексом, чтобы найти наименьшую в лексикографическом порядке подпоследовательность). Это будет индекс перпого элемента искомой подпоследовательности.

\item $l = 0$

\item Восстановим найденную подпоследовательность с помощью массивов $P_<$ и $P_>$ следующим образом:\\
пусть текущий элемент подпоследовательности $x_l = \alpha_{m_k}$, тогда:
	\begin{itemize}
	
	\item если индекс ${m_k}$ был найден в массиве $L_>$, то $m_{k-1} = P_>[m_k]$;

	\item если индекс ${m_k}$ был найден в массиве $L_<$, то $m_{k-1} = P_<[m_k]$;
	
	\item если $m_{k-1} = -1$, переходим к пункту 7;
	
	\item $l = l + 1$
	
	\end{itemize}
	
\item Меняем массив поиска с $L_>$ на $L_<$ или наоборот. Далее повторяем предыдущий пункт.
	
\item Подпоследовательность $\alpha_0\dots\alpha_l$ - искомая последовательность.
	
\end{enumerate}
	



\section{Доказательство корректнсти}
Доказательство будем строить по индукции. Для одного элемента алгоритм работает корректно. Предположим, что для $n$ элементов алгоритм также работает корректно. Рассмотрим ситуацию, когда к последоветельности из $n$ элементов добавдяется еще один.\\
Заполнять элементы массивов $P_<$ и $P_>$ будем следующим образом:

$$P_>[n]=\operatorname*{arg\ max}\limits_{0\le i < n;\;\; \alpha_j>\alpha_i} (L_<[i])$$
$$P_<[n]=\operatorname*{arg\ max}\limits_{0\le i < n;\;\; \alpha_j<\alpha_i} (L_>[i])$$
при этом для выполнения условия вывода последовательности с минимальным $i_k$ будем выбирать самые левые из возможных индексов. 

Заполнять элементы массивов $L_<$ и $L_>$ будем следующим образом:
$$L_>[n] = L_<[P_<[n]] + 1$$
$$L_<[n] = L_>[P_>[n]] + 1$$

Предположим, что найденная чередующейся подпоследовеьтльность не является наибольшей, но в таком случае существует другая чередующаяся подпоследовательность $\alpha_{m_0}\dots\alpha_{m_k}\alpha_n $, такая что $\alpha_{m_k} > \alpha_n$, следоветельно $L_<[m_k] > L_<[P_>[n]]$, что протеворечит ранее описаным условиям 
$$P_>[n]=\operatorname*{arg\ max}\limits_{0\le i < n;\;\; \alpha_j>\alpha_i} (L_<[i])$$
Таким образом $\alpha_{x_0}\dots\alpha_{P_>[n]}\alpha_n$ является наибольшей чередующейся подпоследовательностью. Аналогичным образом доказывем корректность для $P_<[n]$

В итоге получаем предыдущий индекс для каждого элемента последоветльности и длины наибольших чередующеихся подпоследовательностей. Из этих данных легко восстановить наибольшую чередующуюся подпоследовательность $\alpha_{x_0}\dots\alpha_{x_k}\alpha_n$ входной последовательности.


\section{Асимптотические оценки}
В результате получаем сложность по памяти $O(n)$, так как мы используем 4 массива длиной $n$.Cложность по времени равна $O(n^2)$, так как для каждого элемента $\alpha_i$, где $0 < i < n-1$ просматривается не более $n$ элементов для массивов $L_<$ и $L_>$, а для восстановления индексов последовательности просматривется не более $n$ элементов из массивов $P_<$ и $P_>$ и не более $n$ элементов исходного массива для восстановления самой последоветльности.



\end{document}